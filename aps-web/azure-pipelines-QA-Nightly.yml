# ASP.NET Core (.NET Framework)
# Build and test ASP.NET Core projects targeting the full .NET Framework.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/dotnet-core

# trigger:
# - Dev


stages:
- stage: 'Build'
  displayName: 'Build the web application'
  jobs: 
  - job: 'Build'
    displayName: 'Build job'
    pool:
      name: 'PTWebBuildMachines'

    variables:
      solution: '**/*.sln'
      project: '**/WebApps/ReportsWebApp.csproj'
      buildPlatform: 'Any CPU'
      buildConfiguration: 'Release'


    steps:
    - task: NuGetToolInstaller@1

    - task: NuGetCommand@2
      inputs:
        command: 'restore'
        restoreSolution: '$(solution)'
        feedsToUse: 'config'

    - task: VSBuild@1
      inputs:
        solution: '$(project)'
        vsVersion: '17.0'
        msbuildArgs: '/p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=true 
        /p:SkipInvalidConfigurations=true /p:DesktopBuildPackageLocation="$(Build.ArtifactStagingDirectory)\WebApp.zip" 
        /p:DeployIisAppPath="Default Web Site"'
        platform: '$(buildPlatform)'
        configuration: '$(buildConfiguration)'
        customVersion: '17.8'

# Apply migrations from the ReportsWebApp.DB project (NOT the prod migrations) to db in appsettings.json file. 
     # This is a useful step for our nightly builds, but shouldn't be copied to the production environment where we want direct control.
    - script: dotnet ef database update --context DbReportsContext --project $(Build.SourcesDirectory)/ReportsWebApp.DB/ReportsWebApp.DB.csproj --startup-project $(Build.SourcesDirectory)/WebApps/ReportsWebApp.csproj --connection "$(ConnectionString-WebApp-QA)"
      displayName: 'Run EF Core Migration'
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/dev'))

     #Publish build results for use in the release pipelines
    - task: PublishBuildArtifacts@1
      inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)'
          ArtifactName: 'drop'
          publishLocation: 'Container'

  #Publish to azure app service
- stage: 'PT_WebApp_QA'
  displayName: 'Deploy the web application to QA'
  jobs:
  - deployment: Deploy
    environment: PT-WebApp-Dev
  - job: 'Deploy_to_QA'
    displayName: 'Deploy to QA job'
    pool:
      name: 'PTWebBuildMachines'
      environment: PT-WebApp-Dev

    variables:
      #solution: '**/*.sln'
      project: '**/WebApps/ReportsWebApp.csproj'
      buildPlatform: 'Any CPU'
      buildConfiguration: 'Release'
      System.Debug: 'true'
      ConnectionStrings.WebAppDatabase: $(ConnectionString-WebApp-QA)
      CosmosDb.EndpointUri: $(CosmosDBEndpointUriDev)
      CosmosDb.PrimaryKey: $(CosmosDBPrimaryKey)
      Auth0.Domain: $(Auth0DomainDev)
      Auth0.ClientId: $(Auth0ClientIdDev)
      PowerBI.TenantId: $(PowerBITenantIdDev)
      PowerBI.ApplicationId: $(PowerBIApplicationIdDev)
      PowerBI.ApplicationSecret: $(PowerBIApplicationSecretDev)
      AzureSMBStorageConnectionString: $(AzureSMBStorageCS)
      AzureImportQueueName: $(AzureImportQueueName-QA)
      Environment: $(Webapp-Environment-QA)
      APPINSIGHTS_INSTRUMENTATIONKEY: $(Webapp-Appinsight-QA)
      ApiUrl: $(ApiUrl-QA)
        
    steps:
    - download: current
      #artifact: drop
    
    # File transform
    # Replace tokens with variable values in XML or JSON configuration files
    - task: FileTransform@1
      displayName: 'File transformation: appsettings.json'
      inputs:
        folderPath: '$(Pipeline.Workspace)/drop/*.zip'
        targetFiles: '**/appsettings.json' 
        fileType: json

    - task: AzureRmWebAppDeployment@4
      inputs:
          ConnectionType: 'AzureRM'
          azureSubscription: '76e01371-5a04-44df-b577-3affc90d9712'
          appType: 'webApp'
          WebAppName: 'pt-app-qa'
          packageForLinux: '$(Pipeline.Workspace)/drop/*.zip'
