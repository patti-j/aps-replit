using System.Text;
using System.Xml.Linq;

namespace PT.Common.File;

/// <summary>
/// Allows you to easily log basic error message to a text file at the base of the c-drive through the use of
/// static functions.
/// </summary>
public class SimpleExceptionLogger
{
    #region Construction. You can't create instances of this class because all the members are static.
    protected SimpleExceptionLogger() { }
    #endregion

    #region Public static stuff such as a function to count the number of start of entry markers.
    /// <summary>
    /// Count the number of StartOfEntryMarkers that are in the string that you pass in.
    /// This should indicate the number of entries logged in an error file.
    /// </summary>
    /// <param name="a_log">The contents of a log generated by this class.</param>
    /// <returns></returns>
    public static int CountStartOfEntryMarkers(string a_log)
    {
        int count = 0;
        int indexOfEntryFound;

        indexOfEntryFound = a_log.IndexOf(START_ENTRY_TEXT, 0);

        while (indexOfEntryFound >= 0)
        {
            ++count;
            indexOfEntryFound = a_log.IndexOf(START_ENTRY_TEXT, indexOfEntryFound + START_ENTRY_TEXT.Length);
        }

        return count;
    }

    /// <summary>
    /// Returns the string with details such as stack traces removed for simple display to the user.
    /// </summary>
    /// <param name="a_rawLogContents"></param>
    /// <returns></returns>
    public static string FilterLogContents(string a_rawLogContents, bool a_startInUserText = false)
    {
        //Split the text into a string array by end of line deliminator
        string[] eolChar = { Environment.NewLine };
        string[] allLines = a_rawLogContents.Split(eolChar, StringSplitOptions.None);
        StringBuilder builder = new ();
        bool inUserText = a_startInUserText; //flag whether the iterator is currently at text that should be included for the user
        for (int i = 0; i < allLines.Length; i++)
        {
            string curLine = allLines[i];
            if (curLine.StartsWith(EXCEPTION_MESSAGE_TEXT))
            {
                i++; //Skip the next line which is the exception type.
                inUserText = true;
                continue;
            }

            if (curLine.StartsWith(EXCEPTION_INNER_EXCEPTION_MESSAGE_TEXT))
            {
                inUserText = true;
                continue;
            }

            if (curLine.StartsWith(NOTIFICATION_INFO_TEXT))
            {
                inUserText = false;
                continue;
            }

            if (curLine.StartsWith(START_ENTRY_TEXT))
            {
                inUserText = true;
            }
            else if (curLine.StartsWith("***"))
            {
                if (inUserText)
                {
                    builder.Append(Environment.NewLine);
                }

                inUserText = false;
            }

            if (inUserText)
            {
                if (!string.IsNullOrWhiteSpace(curLine))
                {
                    builder.AppendLine(curLine);
                }
            }
        }

        return builder.ToString();
    }

    public static string FormatLogContents(string a_rawLogContents)
    {
        //Split the text into a string array by end of line deliminator
        string[] eolChar = { Environment.NewLine };
        string[] allLines = a_rawLogContents.Split(eolChar, StringSplitOptions.None);
        StringBuilder builder = new ();
        for (int i = 0; i < allLines.Length; i++)
        {
            string curLine = allLines[i];

            if (!string.IsNullOrWhiteSpace(curLine))
            {
                if (curLine.StartsWith(".......") && i != 0)
                {
                    builder.Append(Environment.NewLine);
                }

                builder.AppendLine(curLine);
            }
        }

        return builder.ToString();
    }

    /// <summary>
    /// Truncate a PlanetTogether log down to a certain number of newest entries.
    /// This is intended for use when overly large logs may present and issue (e.g. when transferring over API)
    /// </summary>
    /// <param name="a_rawLogContents"></param>
    /// <param name="a_maxLogCount"></param>
    /// <returns></returns>
    public static string TruncateLogs(string a_rawLogContents, int a_maxLogCount = 1000)
    {
        //Split the text by the standard log header
        string[] logs = a_rawLogContents.Split(START_ENTRY_TEXT, StringSplitOptions.None)
                                        .Skip(1) // Omit content before first header (should be empty string)
                                        .ToArray();

        // Since logs are descending, get bottom N
        IEnumerable<string> newestNLogs = Enumerable.Reverse(logs)
                                                    .Take(a_maxLogCount)
                                                    .Reverse();

        StringBuilder builder = new ();
        foreach (string log in newestNLogs)
        {
            // Re-add filtered headers along with their content
            builder.Append(START_ENTRY_TEXT).Append(log);
        }

        return builder.ToString();
    }
    #endregion

    #region Error logging.
    #region Constants defining things like the start of an entry.
    /// <summary>
    /// Use this log file when no other is appropriate and you don't want to create a new one. The message ends up
    /// in a log file stored at the location relative to where the program is run. The log name is
    /// "PTDefault.Log".
    /// This log is also used by the exception logger itself in the event that an exception occurs while an exception is being logged.
    /// </summary>
    /// <param name="a_e">This can be null.</param>
    /// <param name="a_extraText">Extra text is not mandatory. Though it makes no sense to have no text and a null exception.</param>
    public static void PTDefaultLog(Exception a_e, string a_extraText)
    {
        try
        {
            LogException(PTDefaultLogName, a_e, a_extraText);
        }
        catch (Exception)
        {
            // Logging has failed. Passing to avoid potential loops.
        }
    }

    public static readonly string START_ENTRY_TEXT = "....... START ENTRY ";
    public static readonly string TRAIL_TEXT = ".......";
    public static readonly string MESSAGE_TEXT = "*** Message ***";
    public static readonly string NOTIFICATION_INFO_TEXT = "*** Notification Info ***";
    public static readonly string EXCEPTION_MESSAGE_TEXT = "***   Exception.Message   ***";
    public static readonly string EXCEPTION_STACK_TRACE_TEXT = "*** Exception.StackTrace ***";
    public static readonly string EXCEPTION_SOURCE_TEXT = "*** Exception.Source ***";
    public static readonly string EXCEPTION_INNER_EXCEPTION_MESSAGE_TEXT = "*** Exception.InnerException.Message ***";
    public static readonly string EXCEPTION_INNER_EXCEPTION_STACK_TRACE_TEXT = "*** Exception.InnerException.StackTrace ***";
    public static readonly string APS_EVENT_LOG_NAME = "Application"; //For some reason attempting to register a source in "APS - Advanced Planning and Scheduling" doesn't work so we have to log to Application
    public static readonly string LOGIN_ERROR_LOG_NAME = "LogInDialogErrors.log";
    public static readonly string STARTUP_ERROR_LOG_NAME = "StartupSystemRetrievalInvalidLogons.log";
    public static readonly string LOGIN_ERROR_TITLE = "Login Error";
    public static readonly string STARTUP_ERROR_TITLE = "Startup Error";
    public static readonly string CLIENT_UPDATER_LOG_NAME = "APS Client Updater.log";
    public static readonly string CLIENT_UPDATER_TITLE = "Client Updater Error";

    public enum PTEventId
    {
        STARTED_SUCCESSFULLY = 55000,
        STOPPED_SUCCESSFULLY = 55001,
        FAILED_TO_START = 55002,
        UNHANDLED_EXCEPTION = 55003,
        EXCEPTION = 55004,
        MESSAGE = 55005,
        ERROR_MESSAGE = 55006,
        SYSTEM_SHUTDOWN = 55007,
        SHUTDOWN_REASON = 55008,
        MANUAL_INPUT = 55009
    }

    #region XML Element Names. For use with logs that are written as xml elements.
    public static readonly string c_xmlDate = "Date";
    public static readonly string c_xmlUTCDateTicks = "UTCDateTicks";
    public static readonly string c_xmlPtVersion = "PTVersion";
    public static readonly string c_xmlScenarioName = "ScenarioName";
    public static readonly string c_xmlScenarioType = "ScenarioType";
    public static readonly string c_xmlScenarioCreationDate = "ScenarioCreationDate";
    public static readonly string c_xmlPtSerializationVersionNumber = "PTSerializationVersion";
    public static readonly string c_xmlLogEntry = "LogEntry";
    public static readonly string c_xmlMessageText = "Message";
    public static readonly string c_xmlExceptionTypeName = "ExceptionTypeName";
    public static readonly string c_xmlExceptionMessageText = "Exception.Message";
    public static readonly string c_xmlExceptionStackTraceText = "Exception.StackTrace";
    public static readonly string c_xmlExceptionSourceText = "Exception.Source";
    public static readonly string c_xmlExceptionInnerExceptionMessageText = "Exception.InnerException.Message";
    public static readonly string c_xmlExceptionInnerExceptionStackTraceText = "Exception.InnerException.StackTrace";
    #endregion
    #endregion

    #region Text formatted file logging
    /// <summary>
    /// Log a non-error.
    /// </summary>
    /// <param name="a_logName">
    /// Name of the file. Optionally include the full path. If You don't include the path then the file will be written either in the default folder or the folder where the program is
    /// being run from.
    /// </param>
    /// <param name="a_message">The text you want saved in the log.</param>
    public static void LogMessage(string a_logName, string a_message)
    {
        StringBuilder sb = new ();
        sb.AppendFormat(Environment.NewLine + "{0}   {1}       PT Version={2}  PT Serialization Version={3}",
            START_ENTRY_TEXT,
            DateTimeOffset.Now,
            AssemblyVersionChecker.GetAssemblyVersion(),
            Serialization.VersionNumber);

        sb.Append(Environment.NewLine);
        sb.Append(a_message);
        sb.Append(Environment.NewLine);

        LogMessageToDisk(a_logName, sb.ToString());
    }

    /// <summary>
    /// Log to the application folder.
    /// </summary>
    public static void LogExceptionToStartupFolder(string a_fileName, Exception a_exception)
    {
        string fileWithPath = Path.Combine(AppContext.BaseDirectory, a_fileName);
        LogException(fileWithPath, a_exception);
    }

    public static void LogException(string a_fullLogFilePath, string a_extraText)
    {
        ExceptionDescriptionInfo edi = new ();
        LogException(a_fullLogFilePath, edi, a_extraText);
    }

    public static void LogPackageException(string a_fullLogFilePath, string a_message)
    {
        //Handle if the log path is invalid
        if (string.IsNullOrEmpty(a_fullLogFilePath))
        {
            PTDefaultLog(new Exception("4046: No log file path was specified."), "PackagesPath");
            return;
        }

        using (FileStream fs = System.IO.File.Open(a_fullLogFilePath, FileMode.Append, FileAccess.Write))
        {
            UTF8Encoding utf8Encoding = new ();
            StringBuilder sb = new ();
            sb.AppendFormat(Environment.NewLine + "{0}   {1}       PT Version={3}  PT Serialization Version={4} {2}",
                START_ENTRY_TEXT,
                DateTimeOffset.Now,
                TRAIL_TEXT,
                AssemblyVersionChecker.GetAssemblyVersion(),
                Serialization.VersionNumber);

            sb.Append(a_message);
            StringBuilder msg = sb.Append(Environment.NewLine);
            WriteString(fs, utf8Encoding, msg.ToString());
        }
    }

    public static void LogPackageExceptions(string a_fullLogFilePath, Dictionary<string, HashSet<string>> a_errors)
    {
        //Handle if the log path is invalid
        if (string.IsNullOrEmpty(a_fullLogFilePath))
        {
            PTDefaultLog(new Exception("4046: No log file path was specified."), "PackagesPath");
            return;
        }

        try
        {
            foreach (KeyValuePair<string, HashSet<string>> category in a_errors)
            {
                if (category.Value.Count > 0)
                {
                    StringBuilder sb = new ();
                    sb.AppendFormat(Environment.NewLine + "{0}   {1}       PT Version={3}  PT Serialization Version={4} {2}",
                        START_ENTRY_TEXT,
                        DateTimeOffset.Now,
                        TRAIL_TEXT,
                        AssemblyVersionChecker.GetAssemblyVersion(),
                        Serialization.VersionNumber);

                    if (!string.IsNullOrEmpty(category.Key))
                    {
                        sb.Append(Environment.NewLine + MESSAGE_TEXT + Environment.NewLine);
                        sb.Append(category.Key + Environment.NewLine);
                    }

                    foreach (string packageInfo in category.Value)
                    {
                        sb.Append(Environment.NewLine + packageInfo);
                    }

                    using (FileStream fs = System.IO.File.Open(a_fullLogFilePath, FileMode.Append, FileAccess.Write))
                    {
                        UTF8Encoding utf8Encoding = new ();
                        StringBuilder msg = sb.Append(Environment.NewLine);
                        WriteString(fs, utf8Encoding, msg.ToString());
                    }
                }
            }
        }
        catch (Exception exception)
        {
            if (a_fullLogFilePath == PTDefaultLogName)
            {
                throw new CommonException(string.Format("Error writing to log path: {0}.  {1}", a_fullLogFilePath, exception.Message));
            }

            string extraMsg = $"4045: {a_fullLogFilePath}";

            PTDefaultLog(exception, extraMsg);
        }
    }

    /// <summary>
    /// Log an exception to the specified file.
    /// </summary>
    /// <param name="a_fullLogFilePath">The full path of the file you want ot log the exception to.</param>
    /// <param name="a_e">The error you want to log. This value can be null.</param>
    /// <param name="a_extraText">Some additional text that you want to log in addition to the exception.</param>
    public static void LogException(string a_fullLogFilePath, Exception a_e, string a_extraText = "")
    {
        ExceptionDescriptionInfo edi = new (a_e);
        LogException(a_fullLogFilePath, edi, a_extraText);
    }

    public static void LogException(string a_fullLogFilePath, ExceptionDescriptionInfo a_edi, string a_extraText)
    {
        LogException(a_fullLogFilePath, a_edi, new ScenarioExceptionInfo(), a_extraText, false, null);
    }

    public static void LogException(string a_fullLogFilePath, ExceptionDescriptionInfo a_edi, ScenarioExceptionInfo a_sei, string a_extraText)
    {
        LogException(a_fullLogFilePath, a_edi, a_sei, a_extraText, false, null);
    }
    #endregion

    #region XML Versions. All of these will lead to XML formatted file logging.
    /// <summary>
    /// Log using XML formatted file logging.
    /// </summary>
    /// <param name="a_fullLogFilePath"></param>
    /// <param name="a_xmlText"></param>
    public static void LogException(string a_fullLogFilePath, XElement a_xmlText)
    {
        ExceptionDescriptionInfo edi = new ();
        LogException(a_fullLogFilePath, edi, new ScenarioExceptionInfo(), "", true, a_xmlText);
    }

    /// <summary>
    /// Log using XML formatted file logging.
    /// </summary>
    /// <param name="a_fullLogFilePath"></param>
    /// <param name="a_e"></param>
    /// <param name="a_extraText"></param>
    /// <param name="a_xmlText"></param>
    public static void LogException(string a_fullLogFilePath, Exception a_e, string a_extraText, XElement a_xmlText)
    {
        ExceptionDescriptionInfo edi = new (a_e);
        LogException(a_fullLogFilePath, edi, new ScenarioExceptionInfo(), a_extraText, true, a_xmlText);
    }

    /// <summary>
    /// Log using XML formatted file logging.
    /// </summary>
    /// <param name="a_fullLogFilePath"></param>
    /// <param name="a_e"></param>
    /// <param name="a_xmlText"></param>
    public static void LogException(string a_fullLogFilePath, Exception a_e, XElement a_xmlText)
    {
        ExceptionDescriptionInfo edi = new (a_e);
        LogException(a_fullLogFilePath, edi, new ScenarioExceptionInfo(), "", true, a_xmlText);
    }

    /// <summary>
    /// Log using XML formatted file logging.
    /// </summary>
    /// <param name="a_fullLogFilePath"></param>
    /// <param name="a_extraText"></param>
    public static void LogExceptionTextAsXML(string a_fullLogFilePath, string a_extraText)
    {
        ExceptionDescriptionInfo edi = new ();
        LogException(a_fullLogFilePath, edi, new ScenarioExceptionInfo(), a_extraText, true, null);
    }
    #endregion

    private static readonly Dictionary<string, object> s_fileLockDict = new ();
    private static readonly object s_fileLockDictLock = new ();

    /// <summary>
    /// String description information about an exception.
    /// </summary>
    private static void LogException(string a_fullLogFilePath, ExceptionDescriptionInfo a_edi, ScenarioExceptionInfo a_sei, string a_extraText, bool a_formatAsXML, XElement a_xmlElement)
    {
        //Handle if the log path is invalid
        if (string.IsNullOrEmpty(a_fullLogFilePath))
        {
            PTDefaultLog(new Exception("4046: No log file path was specified."), a_edi?.Message);
            return;
        }

        //Find the correct file lock or create a new one.
        object fileLock;

        lock (s_fileLockDictLock)
        {
            if (!s_fileLockDict.TryGetValue(a_fullLogFilePath, out fileLock))
            {
                fileLock = new object();
                s_fileLockDict.Add(a_fullLogFilePath, fileLock);
            }
        }

        lock (fileLock)
        {
            try
            {
                if (System.IO.File.Exists(a_fullLogFilePath))
                {
                    FileInfo fi = new (a_fullLogFilePath);

                    // The maximum length an error log is limited to.
                    const long MAX_SIZE = 5242880;

                    if (fi.Length > MAX_SIZE)
                    {
                        string fullLogFilePathOld = $"{a_fullLogFilePath}_OLD";

                        // The current log is too large.
                        // Rename the current log to a name inidcating it is now the old log.
                        if (System.IO.File.Exists(fullLogFilePathOld))
                        {
                            // If there is already an old log, get rid of it.
                            System.IO.File.Delete(fullLogFilePathOld);
                        }

                        System.IO.File.Move(a_fullLogFilePath, fullLogFilePathOld);
                    }
                }

                using (FileStream fs = System.IO.File.Open(a_fullLogFilePath, FileMode.Append, FileAccess.Write))
                {
                    UTF8Encoding utf8Encoding = new ();
                    string msg;
                    if (a_formatAsXML || a_xmlElement != null)
                    {
                        msg = CreateErrorMsgXMLString(a_edi, a_sei, a_extraText, a_xmlElement);
                    }
                    else
                    {
                        msg = CreateErrorMsgString(a_edi, a_sei, a_extraText);
                    }

                    WriteString(fs, utf8Encoding, msg);
                }
            }
            catch (Exception exception)
            {
                if (a_fullLogFilePath == PTDefaultLogName)
                {
                    throw new CommonException(string.Format("Error writing to log path: {0}.  {1}", a_fullLogFilePath, exception.Message));
                }

                string extraMsg = $"4045: {a_fullLogFilePath}";

                PTDefaultLog(exception, extraMsg);
            }
        }
    }

    private static void LogMessageToDisk(string a_fullLogFilePath, string a_message)
    {
        //Handle if the log path is invalid
        if (string.IsNullOrEmpty(a_fullLogFilePath))
        {
            PTDefaultLog(new Exception("4046: No log file path was specified."), "");
            return;
        }

        //Find the correct file lock or create a new one.
        object fileLock;

        lock (s_fileLockDictLock)
        {
            if (!s_fileLockDict.TryGetValue(a_fullLogFilePath, out fileLock))
            {
                fileLock = new object();
                s_fileLockDict.Add(a_fullLogFilePath, fileLock);
            }
        }

        lock (fileLock)
        {
            try
            {
                if (System.IO.File.Exists(a_fullLogFilePath))
                {
                    FileInfo fi = new (a_fullLogFilePath);

                    // The maximum length an error log is limited to.
                    const long MAX_SIZE = 5242880;

                    if (fi.Length > MAX_SIZE)
                    {
                        string fullLogFilePathOld = $"{a_fullLogFilePath}_OLD";

                        // The current log is too large.
                        // Rename the current log to a name inidcating it is now the old log.
                        if (System.IO.File.Exists(fullLogFilePathOld))
                        {
                            // If there is already an old log, get rid of it.
                            System.IO.File.Delete(fullLogFilePathOld);
                        }

                        System.IO.File.Move(a_fullLogFilePath, fullLogFilePathOld);
                    }
                }

                using (FileStream fs = System.IO.File.Open(a_fullLogFilePath, FileMode.Append, FileAccess.Write))
                {
                    UTF8Encoding utf8Encoding = new ();
                    WriteString(fs, utf8Encoding, a_message);
                    WriteString(fs, utf8Encoding, Environment.NewLine);
                }
            }
            catch (Exception exception)
            {
                if (a_fullLogFilePath == PTDefaultLogName)
                {
                    throw new CommonException(string.Format("Error writing to log path: {0}.  {1}", a_fullLogFilePath, exception.Message));
                }

                string extraMsg = $"4045: {a_fullLogFilePath}";

                PTDefaultLog(exception, extraMsg);
            }
        }
    }

    /// <summary>
    /// Create a formatted error message based on the settings in an ExceptionDescriptionInfo and any additional text.
    /// </summary>
    /// <param name="a_edi">Any set field is included as part of the error message.</param>
    /// <param name="a_sei">If not null, display infor about scenario where error occurred</param>
    /// <param name="a_extraText">if set this is included near the top of the error message.</param>
    /// <returns></returns>
    public static string CreateErrorMsgString(ExceptionDescriptionInfo a_edi, ScenarioExceptionInfo a_sei, string a_extraText)
    {
        StringBuilder sb = new ();
        sb.AppendFormat(Environment.NewLine + "{0}   {1}       PT Version={3}  PT Serialization Version={4} {2}",
            START_ENTRY_TEXT,
            DateTimeOffset.Now,
            TRAIL_TEXT,
            AssemblyVersionChecker.GetAssemblyVersion(),
            Serialization.VersionNumber);

        if (a_sei != null && a_sei.Initialized)
        {
            sb.Append(Environment.NewLine);
            sb.AppendLine("=======================================");
            sb.AppendFormat("Scenario Name: {1}{0}Scenario Type: {2}{0}Scenario Creation Date: {3}{0}", Environment.NewLine, a_sei.ScenarioName, a_sei.ScenarioType, a_sei.ScenarioCreationDate);
            sb.AppendLine("=======================================");
        }

        if (a_edi != null)
        {
            if (!string.IsNullOrEmpty(a_extraText))
            {
                sb.Append(Environment.NewLine + MESSAGE_TEXT + Environment.NewLine);
                sb.Append(a_extraText);
            }

            if (a_edi.Message.Length > 0)
            {
                sb.Append(Environment.NewLine + Environment.NewLine + EXCEPTION_MESSAGE_TEXT + Environment.NewLine);
                string message = a_edi.GetTypeName + ": " + Environment.NewLine + a_edi.Message + Environment.NewLine;
                sb.Append(message);
            }

            if (a_edi.StackTrace.Length > 0)
            {
                sb.Append(Environment.NewLine + EXCEPTION_STACK_TRACE_TEXT + Environment.NewLine);
                sb.Append(a_edi.StackTrace);
            }

            if (a_edi.Source.Length > 0)
            {
                sb.Append(Environment.NewLine + EXCEPTION_SOURCE_TEXT + Environment.NewLine);
                sb.Append(a_edi.Source);
            }
        }

        //space between errors
        sb.Append(Environment.NewLine);

        return sb.ToString();
    }

    private static string CreateErrorMsgXMLString(ExceptionDescriptionInfo a_edi, ScenarioExceptionInfo a_sei, string a_extraText, XElement a_element)
    {
        DateTimeOffset now = DateTimeOffset.Now;
        long nowUTCTicks = now.ToUniversalTime().Ticks;
        XElement logElement;
        if (a_sei != null && a_sei.Initialized)
        {
            logElement = new XElement(c_xmlLogEntry,
                new XElement(c_xmlDate, now.ToString()),
                new XElement(c_xmlUTCDateTicks, nowUTCTicks.ToString()),
                new XElement(c_xmlPtVersion, AssemblyVersionChecker.GetAssemblyVersion().ToString()),
                new XElement(c_xmlPtSerializationVersionNumber, Serialization.VersionNumber.ToString()),
                new XElement(c_xmlScenarioName, a_sei.ScenarioName),
                new XElement(c_xmlScenarioType, a_sei.ScenarioType),
                new XElement(c_xmlScenarioCreationDate, a_sei.ScenarioCreationDate));
        }
        else
        {
            logElement = new XElement(c_xmlLogEntry,
                new XElement(c_xmlDate, now.ToString()),
                new XElement(c_xmlUTCDateTicks, nowUTCTicks.ToString()),
                new XElement(c_xmlPtVersion, AssemblyVersionChecker.GetAssemblyVersion().ToString()),
                new XElement(c_xmlPtSerializationVersionNumber, Serialization.VersionNumber.ToString()));
        }

        if (a_element != null)
        {
            logElement.Add(a_element);
        }

        if (!string.IsNullOrEmpty(a_extraText))
        {
            AddXmlElement(logElement, c_xmlMessageText, a_extraText);
        }

        AddXmlElement(logElement, c_xmlExceptionTypeName, a_edi.GetTypeName);
        AddXmlElement(logElement, c_xmlExceptionMessageText, a_edi.Message);
        AddXmlElement(logElement, c_xmlExceptionStackTraceText, a_edi.StackTrace);
        AddXmlElement(logElement, c_xmlExceptionSourceText, a_edi.Source);

        return logElement + Environment.NewLine + Environment.NewLine;
    }

    private static void AddXmlElement(XElement a_parentElement, string a_newElementName, string a_newElementBody)
    {
        if (a_newElementBody.Length > 0)
        {
            XElement newElement = new (a_newElementName, a_newElementBody);
            a_parentElement.Add(newElement);
        }
    }
    #endregion

    #region Helpers
    /// <summary>
    /// Write the text to the file stream, using the specified byte encoding.
    /// </summary>
    /// <param name="a_fs"></param>
    /// <param name="a_utf8Encoding"></param>
    /// <param name="a_txt"></param>
    private static void WriteString(FileStream a_fs, UTF8Encoding a_utf8Encoding, string a_txt)
    {
        if (a_txt != null)
        {
            byte[] bytes = a_utf8Encoding.GetBytes(a_txt);
            a_fs.Write(bytes, 0, bytes.Length);
        }
    }

    /// <summary>
    /// Write the text suffixed by a "new line" to the file stream, using the specified byte encoding.
    /// </summary>
    /// <param name="a_fs"></param>
    /// <param name="a_utf8Encoding"></param>
    /// <param name="a_txt"></param>
    private static void WriteStringLine(FileStream a_fs, UTF8Encoding a_utf8Encoding, string a_txt)
    {
        if (a_txt != null)
        {
            string textStringLine = string.Format("{0}{1}", a_txt, Environment.NewLine);
            WriteString(a_fs, a_utf8Encoding, textStringLine);
        }
    }

    /// <summary>
    /// Path for a file on the Desktop for writing errors encountered when the working directory is no good.
    /// </summary>
    public static string PTDefaultLogName => Path.Combine(Environment.CurrentDirectory, "PTDefault.Log");
    #endregion
}