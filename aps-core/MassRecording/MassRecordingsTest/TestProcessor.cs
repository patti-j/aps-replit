using System.Data;
using System.Diagnostics;
using System.Text;

using MassRecordingPlayer;

using MassRecordings;

using Microsoft.VisualStudio.TestTools.UnitTesting;

using PT.Common.Extensions;
using PT.Common.Sql.SqlServer;

namespace MassRecordingsTest;

internal class TestProcessor
{
    private string m_fullRecordingPath;
    private readonly StartNewInstance m_instanceConfig;
    private string m_customerPath;
    private string m_recordingName;
    private int m_playerId;
    private bool m_continue;
    private int m_errorCode;
    private static readonly object s_dbLock = new ();

    #if DEBUG
    private const string c_releaseRunMode = "DEBUG";
    #else
        private const string c_releaseRunMode = "RELEASE";
    #endif
    private const string c_mrPlayerExe = "MassRecordingPlayer.exe";

    internal TestProcessor(StartNewInstance a_instanceConfig)
    {
        m_instanceConfig = a_instanceConfig;
    }

    public void SetFullRecordingPath(string a_path, string a_zipFile)
    {
        int index = a_path.IndexOf("V");
        a_path = a_path.Remove(index, 1);

        m_customerPath = a_path;
        m_recordingName = a_zipFile;
        m_fullRecordingPath = Path.Combine(a_path, a_zipFile);
    }

    public static string WorkingDirectory { get; set; }

    /// <summary>
    /// After each test, check PlayerInstances and PlayerExceptions data tables. If Players Exceptions table has entries, extract error message and
    /// assert true to diplay error message on Test Explorer. Perform the same operation for the InstanceLogs table generated by PT. Also check each entry on the Player Instances table and verify the
    /// existence of
    /// a start date, end date and error files. Assert true for the start date and end date and assert false for the error files to display failure message
    /// on the Test Explorer.
    /// </summary>
    public void CheckForErrors()
    {
        MassRecordings.SqlStrings.TableDefinitions.PlayerInstances playerInstDt = new ();
        MassRecordings.SqlStrings.TableDefinitions.PlayerExceptions playerExDt = new ();
        DataTable playerExceptionsDt;

        lock (s_dbLock)
        {
            playerExceptionsDt = m_instanceConfig.DBConnector.SelectSQLTable($"select * from {playerExDt.TableName} where {playerExDt.SessionId} = {m_instanceConfig.SessionId} and {playerExDt.Error} = 'TRUE' and {playerExDt.RecordingPath} = {m_playerId} ");
        }

        int rowsPE = playerExceptionsDt.Rows.Count; //get number of rows in the PlayerExceptions table
        if (rowsPE > 0) //if > 0, an error occured
        {
            string playerError = playerExceptionsDt.Rows[0][playerExDt.ExceptionMessage].ToString();
            string playerStackTrace = playerExceptionsDt.Rows[0][playerExDt.ExceptionTrace].ToString();
            Assert.IsTrue(string.IsNullOrEmpty(playerError), GetAssertionMessage(playerError + Environment.NewLine + playerStackTrace));
        }

        PT.Scheduler.ErrorReporting.SQLErrorLogger mrLogger = new (m_instanceConfig.SessionId.ToString(), m_playerId.ToString(), m_instanceConfig.DBConnectionString, "Exceptions");
        string exceptionError = mrLogger.GetLogContents(false);
        Assert.IsTrue(string.IsNullOrEmpty(exceptionError), GetAssertionMessage(exceptionError)); //if GetLogContents returns a message, PT reported an error, therefore the test fails.

        DataTable playerInstancesDt = m_instanceConfig.DBConnector.SelectSQLTable($"select * from {playerInstDt.TableName} where {playerInstDt.PlayerId} = {m_playerId}");
        int rowsPI = playerInstancesDt.Rows.Count; //get number of rows in PlayerInstance table

        //Check if the player process started
        Assert.IsTrue(rowsPI == 1, "The Player process failed to start.");

        int exitCode = Convert.ToInt32(playerInstancesDt.Rows[0][playerInstDt.ExitCode]);
        Assert.IsFalse(playerInstancesDt.Rows[0][playerInstDt.StartTime] == DBNull.Value, GetAssertionMessage("No start date exists."));
        Assert.IsFalse(playerInstancesDt.Rows[0][playerInstDt.EndTime] == DBNull.Value, GetAssertionMessage("No end date exists."));
        Assert.AreNotEqual(5, exitCode, GetAssertionMessage("There was an issue connecting to the database. "));
        Assert.AreNotEqual(13, exitCode, GetAssertionMessage("The scenarios.dat file for this recording was empty. "));
        Assert.AreEqual(0, exitCode, GetAssertionMessage($"The player terminated unexpectedly and exited with error code {exitCode}"));
    }

    /// <summary>
    /// Adds recording path information to the error message
    /// </summary>
    private string GetAssertionMessage(string a_errorMessage)
    {
        StringBuilder sb = new ();
        sb.AppendLine();
        sb.AppendLine("Unit Test error found:");
        sb.AppendLine($"Recording Name: {m_recordingName}");
        sb.AppendLine($"Recording Path: {m_fullRecordingPath}");
        sb.AppendLine($"Full Local Recording Path: {Path.Combine(m_instanceConfig.RecordingDirectory, m_fullRecordingPath)}");
        sb.AppendLine();
        sb.AppendLine(a_errorMessage);

        return sb.ToString();
    }

    //Handle when CleanUpProcess() has finished in the Player class in MassRecordingsPlayer
    public void HandleFinishEvent(int a_errorCode)
    {
        m_errorCode = a_errorCode;
        m_continue = true;
    }

    public void Test()
    {
        string sourcePath = Path.Combine(m_instanceConfig.MasterCopyPath, m_customerPath);
        string destPath = Path.Combine(m_instanceConfig.RecordingDirectory, m_customerPath);

        lock (s_dbLock)
        {
            string insertInstance = SqlStrings.GetInsertInstanceBase(m_instanceConfig.SessionId, m_fullRecordingPath.CleanString(), DateTime.Now);
            m_playerId = m_instanceConfig.DBConnector.InsertSQLRowAndReturnValue(new[] { insertInstance }, SqlStrings.getCurrentPlayerId().CleanString());
        }

        try
        {
            MasterCopySync mrCopy = new (sourcePath, destPath, m_instanceConfig.SessionId, m_fullRecordingPath, m_instanceConfig.DBConnector);
        }
        catch (Exception e)
        {
            Exception error = new (string.Format("Failed to copy from MasterCopy: Source '{0}' Destination '{1}'", sourcePath, destPath), e);

            lock (s_dbLock)
            {
                string updatePlayerExceptions = MassRecordings.SqlStrings.GetInsertPlayerExceptions(m_instanceConfig.SessionId, m_playerId, error.GetExceptionFullMessage().CleanString(), error.StackTrace.CleanString(), true);
                m_instanceConfig.DBConnector.SendSQLTransaction(new[] { updatePlayerExceptions });
            }

            Assert.Fail(GetAssertionMessage(error.GetExceptionFullMessage()));
        }

        //If no player is being run as a process, start a player class and run the recording without starting a process.
        if (MrTest.CanStartInternally())
        {
            Player mrPlayer = new ();
            mrPlayer.FinishedCleanUpEvent += new Player.CleanUpFinishedHandler(HandleFinishEvent);

            Task.Run(new Action(() => mrPlayer.Start(m_instanceConfig.SessionId, m_fullRecordingPath, m_playerId, false, m_instanceConfig.m_uiPath)));

            //Sleep unitl the CleanUpEvent from the Player Class is raised.
            while (!m_continue)
            {
                Thread.Sleep(3000);
            }

            //Update PlayerInstances with exit code
            lock (s_dbLock)
            {
                string insertPlayerExitCode = SqlStrings.GetUpdateExitCode(m_instanceConfig.SessionId, m_playerId, Convert.ToString(m_errorCode));
                m_instanceConfig.DBConnector.SendSQLTransaction(new[] { insertPlayerExitCode });
            }
        }
        //Run the player as a process
        else
        {
            BeginProcess();
        }
    }

    private void BeginProcess()
    {
        bool run = true;
        int restartsRemaining = m_instanceConfig.RestartCount;
        //Use restartsRemaining+1 or else this will never enter
        while (run && restartsRemaining + 1 > 0)
        {
            try
            {
                Process p = new ();
                p.StartInfo.FileName = Path.Combine(WorkingDirectory.Replace("MassRecordingsTest", "MassRecordingPlayer"), c_mrPlayerExe);
                p.StartInfo.WorkingDirectory = WorkingDirectory;
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.CreateNoWindow = true;
                p.StartInfo.Arguments = string.Format("\"{0}\" \"{1}\" \"{2}\" \"{3}",
                    m_instanceConfig.SessionId,
                    m_fullRecordingPath,
                    m_playerId,
                    m_instanceConfig.m_uiPath);

                p.Start();
                if (!p.WaitForExit(m_instanceConfig.MaxDurationMs))
                {
                    long memoryUsageMB = 0;
                    TimeSpan cpuTime = new (0);
                    float cpuUsage = 0;
                    try
                    {
                        //Get process usages. 
                        memoryUsageMB = p.PrivateMemorySize64 / (2 * 1024);
                        cpuTime = p.TotalProcessorTime;
                        //Player is multithreaded and can return more than 100%.
                        using (PerformanceCounter counter = new ("Process", "% Processor Time", p.ProcessName, true))
                        {
                            counter.NextValue();
                            Thread.Sleep(2000);
                            cpuUsage = counter.NextValue();
                        }
                    }
                    finally
                    {
                        p.Kill();

                        lock (s_dbLock)
                        {
                            string updateInstance = MassRecordings.SqlStrings.GetUpdateInstanceBase(DateTime.Now, memoryUsageMB, cpuTime.Ticks, cpuUsage, m_instanceConfig.SessionId, m_playerId);
                            string updateErrorLog = MassRecordings.SqlStrings.GetInsertPlayerExceptions(m_instanceConfig.SessionId, m_playerId, "Recording Timed Out.", "No stack trace available.", true);
                            m_instanceConfig.DBConnector.SendSQLTransaction(new[] { updateInstance, updateErrorLog });
                        }
                    }

                    return;
                }

                if (p.ExitCode < 0)
                {
                    restartsRemaining--;
                    continue;
                }

                run = false;

                lock (s_dbLock)
                {
                    string insertPlayerExitCode = SqlStrings.GetUpdateExitCode(m_instanceConfig.SessionId, m_playerId, Convert.ToString(p.ExitCode));
                    m_instanceConfig.DBConnector.SendSQLTransaction(new[] { insertPlayerExitCode });
                }
            }
            catch (Exception e)
            {
                string errorMsg = e.GetExceptionFullMessage();
                lock (s_dbLock)
                {
                    string updateErrorLog = MassRecordings.SqlStrings.GetInsertPlayerExceptions(m_instanceConfig.SessionId, m_playerId, errorMsg, e.StackTrace, true);
                    m_instanceConfig.DBConnector.SendSQLTransaction(new[] { updateErrorLog });
                }
            }
        }
    }
}

public class StartNewInstance
{
    public int SessionId;
    public DatabaseConnections DBConnector;
    public string ComputerName;
    public readonly string DBConnectionString;
    public int RestartCount;
    public int MaxDurationMs;
    public string MasterCopyPath;
    public string RecordingDirectory;
    public string m_uiPath;

    public StartNewInstance()
    {
        SimpleConfiguration configuration = new ();
        DBConnectionString = configuration.LoadValue("DBConnectionString");
        m_uiPath = configuration.LoadValue("UIPath");
        MRdbInstallation dbInst = new ();
        MRUtilities mrKill = new ();
        mrKill.KillMRProcesses();
        //Verify all the datatable are installed
        Assert.IsTrue(dbInst.InstallVerification, "One or more of the tables are not installed. Please run the Mass Recordings UI project to install the correct tables.");

        TestProcessor.WorkingDirectory = Environment.CurrentDirectory;
    }

    public void GetInstanceInfo()
    {
        //Database Initializations. Insert a new instance row. Get the current SessionId
        DateTime startTime = DateTime.Now;
        MRTestNumber NumberOfTests = new ();

        MassRecordings.SqlStrings.TableDefinitions.HostConfigurations hostConfigdt = new ();
        DBConnector = new DatabaseConnections(DBConnectionString);
        ComputerName = Environment.MachineName;
        DataTable dt = new ();
        dt = DBConnector.SelectSQLTable(MassRecordings.SqlStrings.GetConfigName(ComputerName));

        Assert.IsFalse(dt.Rows.Count == 0, "The HostConfiguration and HostConfigurationMappings tables are not mapped, please use the MassRecordings UI to map them correctly. ");

        string newSession = SqlStrings.getNewInstanceBase(startTime, Filtering.FilterString(ComputerName), Filtering.FilterString(dt.Rows[0][hostConfigdt.Name].ToString()), Convert.ToInt32(NumberOfTests.MRTestCount()));
        try
        {
            DBConnector.SendSQLTransaction(new[] { newSession });
            string selectId = SqlStrings.getSelectInstanceId(startTime);
            dt = DBConnector.SelectSQLTable(selectId);
            SessionId = Convert.ToInt32(dt.Rows[0][0].ToString());

            dt = DBConnector.SelectSQLTable(MassRecordings.SqlStrings.GetHostConfigTable(Environment.MachineName));
            MasterCopyPath = Convert.ToString(dt.Rows[0][hostConfigdt.MasterCopyPath]);
            RecordingDirectory = Convert.ToString(dt.Rows[0][hostConfigdt.RecordingsDirectory]);
            RestartCount = Convert.ToInt32(dt.Rows[0][hostConfigdt.MaxRestartCount]);
            MaxDurationMs = Convert.ToInt32(dt.Rows[0][hostConfigdt.PlayerTimeOutMS]);
        }
        catch (Exception e)
        {
            Assert.Fail("Unable to connect to the database and insert a new Run Instance. " + e.GetExceptionFullMessage());
        }
    }
}